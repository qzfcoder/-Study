# jsStudy

vo:每一个执行上下文都会被关联到一个变量环境，这个环境就是vo。在源代码中的变量呵函数声明会被作为属性添加到vo中。对于函数来说，参数也会被添加到vo中。



gec（global excution context）全局执行上下文：执行全局代码

fec（functional excution context）函数执行上下文，执行函数代码





## js内存分配

js对基本数据类型内存分配会在执行时候，直接在栈空间进行分配

对于复杂的数据类型内存分配，会在堆内存开辟一块空间，斌在这块空间的指针返回值变量引用

![image-20210905150331523](C:\Users\86730\AppData\Roaming\Typora\typora-user-images\image-20210905150331523.png)

## js垃圾回收机制

因为内存的大小是有限的，所以当内存不在需要的时候，我们需要对其进行释放，腾出更多的内存空间

再手动管理内存的语言中，我们需要通过一些方式自己来释放不要需要的内存，比如free函数：

但是在这种管理方式是十分低效的，影响我们编写代码的效率

并且一不小心会产生内存泄漏

所以现在大部分现代编程语言都有自己的垃圾回收机制

1. 垃圾回收机制简称GC
2. 对于哪些不在使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间
3. 而我们的语言运行环境，比如java 的运行婚检jvm，javascript的运行环境js引擎都会内存垃圾回收器
4. 垃圾回收器我们也称之为GC 所以在很多地方GC都是垃圾回收器

**但是我们这里又出现了一个关键的问题：GC是则么知道哪些对象不在使用了呢**

这时候出来GC算法

### 常见的GC算法

#### 引用计数

```js
var obj = {name: 'qzf'}

var info = {
  name: 'kobe',
  friend: obj
}

var p = {
  name :'james',
  friend: obj
}

// 这时候在堆中有了三个内存空间
// info中friend中指针指向obj的内存空间，p中也是指向obj
// 这时候obj中有一个专门的空间retain count 表示当前的计数，有指向的话 就+1 ，那么现在info 和 p 还有栈空间都指向obj
// 这时候obj中retain count为3，
// 当我们引入计数为0的时候这块内存空间就会被销毁

// 引入计数的弊端：循环引用
```

##### 标记清楚

这个方法是设置一个根对象，垃圾回收器会定期从这个根开始，找到所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用对象

这个算法可以解决循环引用的方法

![image-20210905152407588](C:\Users\86730\AppData\Roaming\Typora\typora-user-images\image-20210905152407588.png)

## 理解js纯函数

纯函数条件

- 这个函数传入相同的输入值，返回的是相同的输出
- 函数输出和输入值以外的其他隐藏信息或状态无关，也和I/O设备产生的 外部输出无关
- 这个函数不能有语义上可以观察的函数副作用，如触发事件，使输出设备输出，或更改输出值以外物件内容

**副作用**：表示在指向一个函数的时候，除了返回函数值以外，还会对调用函数产生了附加的影响，比如修改了全局变量，修改参数或者改变外部存储